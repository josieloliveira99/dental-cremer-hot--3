<footer id="footer">
			<div class="footer-top">
  <div class="privacyPolicy hide" style="display: block;">
    Este site utiliza cookies. Para saber mais <a href="https://www.dentalcremer.com.br/paginainstitucional/politica-privacidade" onclick="javascript:setCookie('privacyPolicy', 'true', 5000);">clique aqui.</a>
  </div>
  <div class="footer-top-content">
    <div class="suggestionProduct">
        <div class="suggestionProduct-icon sprite to-left"></div>
        <h3 class="to-left"><strong>Procurou e não achou?</strong> Qual produto você gostaria de ver na Dental Cremer?</h3>
        <a class="bt-big-primary" href="../../../../../../../../faleconosco?sugerir-produto">Faça sua sugestão</a>
    </div>
    <div class="footer-left align-center">
      <div class="footer-social">
        <a href="https://www.facebook.com/DentalCremer" target="_blank" class="footer-social-facebook sprite">Facebook Dental Cremer</a>
        <a href="http://instagram.com/DentalCremer" target="_blank" class="footer-social-instagram sprite">Instagram Dental Cremer</a>
        <a href="https://twitter.com/dentalcremer" target="_blank" class="footer-social-twitter sprite">Twitter Dental Cremer</a>
        <a href="https://www.youtube.com/user/DentalCremer" target="_blank" class="footer-social-youtube sprite">Youtube Dental Cremer</a>
        <!--a href="https://open.spotify.com/user/dentalcremer" target="_blank" class="footer-social-spotify sprite">Spotify Dental Cremer</a-->
        <a href="https://br.pinterest.com/dentalcremer/" target="_blank" class="footer-social-pintrest sprite">Pintrest Dental Cremer</a>
        <span class="footer-social-partition"></span>
        <a href="http://blog.dentalcremer.com.br/" target="_blank" class="footer-social-blog sprite">Blog Dental Cremer</a>
      </div>
      <div class="footer-contactUs">
        <h4>Atendimento</h4>
        <strong>0800 727 7565</strong>
        <span>Seg. a Sex. das 8h às 22h<br>Sáb. das 8h às 12h</span>
      </div>
    </div>
    <div class="footer-right">
        <div class="footer-institutional">
            <div class="to-left">
              <h3>Institucional</h3>
                <ul>
                  <li><a href="/paginainstitucional/assistente-virtual">Assistente Virtual</a></li>
                  <!--li><a href="/paginainstitucional/catalogovirtual">Catálogo de Ofertas</a></li-->
                  <li><a href="/paginainstitucional/catalogosprodutos">Catálogo de Produtos</a></li>
				  <li><a href="/paginainstitucional/lovers">Dental Cremer Lovers</a></li>
                  <li><a href="/paginainstitucional/resultados-concursos-culturais">Concursos Culturais</a></li>
                  <li><a href="/paginainstitucional/rastreamentopedido">Logística Dental Cremer</a></li>
                  <li><a href="/paginainstitucional/app">Nosso App</a></li>
                  <li><a href="/paginainstitucional/empresa">Sobre a Dental Cremer</a></li>
                  <!--li><a href="https://www.clubeprosaude.com.br" target="_blank">Clube Pro Saúde</a></li-->
                </ul>
            </div>
            <div class="to-left">
                <h3>Ajuda</h3>
                <ul>
                  <li><a href="/paginainstitucional/rastreamentopedido">Acompanhe seu Pedido</a></li>
                  <li><a href="/paginainstitucional/boleto">Atualizar Boleto</a></li>
                  <!--li><a href="/paginainstitucional/conta">Conta Dental Cremer</a></li-->
                  <li><a href="/paginainstitucional/politica-comercial">Política Comercial</a></li>
                  <li><a href="/paginainstitucional/politica-privacidade">Política de Privacidade</a></li>
                </ul>
            </div>
        </div>
        <div class="footer-ebit">
          <a id="seloEbit" href="http://www.ebit.com.br/dental-cremer/selo" target="_blank" onclick="redir(this.href);" style="display: block; overflow: hidden; position: relative;" title="Avaliado pelos consumidores" oncontextmenu="alert(&quot;Cópia proibida! A certificação e-bit é de uso exclusivo de lojas conveniadas à e-bit.&quot;);return false;" value="1"><img src="https://newimgebit-a.akamaihd.net/ebitBR/selo/img_20908.png" style="border: 0px none;"></a>
          <script id="getSelo" type="text/javascript" src="https://imgs.ebit.com.br/ebitBR/selo-ebit/js/getSelo.js?20908&amp;lightbox=true"></script>
        </div>
    </div>
    <div class="footer-infos">
        <div class="footer-apps-mobile">
          	<p class="footer-apps-mobile-tit">Baixe nosso App</p>
          	<a target="_blank" href="//itunes.apple.com/br/app/dental-cremer/id1009320470" class="sprite appStore to-left">Aplicativo Dental Cremer na App Store</a>
          	<a target="_blank" href="//play.google.com/store/apps/details?id=br.com.viewit.dental_cremer_android" class="sprite googlePlay to-left">Aplicativo Dental Cremer no Google Play</a>
        </div>
        <div class="footer-seals">
            <div class="footer-thawte"><a href="javascript: OpenCertDetails()" class="sprite">Certificado pela Thawte</a></div>
          	<a class="footer-procon sprite" href="http://www.procon.sc.gov.br/index.php/atendimento" target="_blank"></a>
        </div>
        <div class="footer-paymentMethods">
          <ul>  	
    <li class="paymentMethodsIcons-li paymentMethodsIcons-li-creditCard">
      <a href="/paginainstitucional/politica-comercial" target="_self"><img alt="Cartão Diners Online" src="https://www.dentalcremer.com.br/assets/templates/1/imagens/rodape_pag_dinners.png?v01"></a>
      <a href="/paginainstitucional/politica-comercial" target="_self"><img alt="Cartão MasterCard Online" src="https://www.dentalcremer.com.br/assets/templates/1/imagens/rodape_pag_master.png?v01"></a>
      <a href="/paginainstitucional/politica-comercial" target="_self"><img alt="Cartão Visa Online" src="https://www.dentalcremer.com.br/assets/templates/1/imagens/rodape_pag_visa.png?v01"></a>
      <a href="/paginainstitucional/politica-comercial" target="_self"><img alt="Cartão American Express" src="https://www.dentalcremer.com.br/assets/templates/1/imagens/rodape_pag_americanExpress.png?v01"></a>
      <a href="/paginainstitucional/politica-comercial" target="_self"><img alt="Cartão Elo" src="https://www.dentalcremer.com.br/assets/templates/1/imagens/rodape_pag_elo.png?v01"></a>
      <a href="/paginainstitucional/politica-comercial" target="_self"><img alt="Pagamento Antecipado" src="https://www.dentalcremer.com.br/assets/templates/1/imagens/rodape_pag_boleto.png?v01"></a>
  	</li>
    <li class="paymentMethodsIcons-li">
      <h5 class="paymentMethodsIcons-li-h5">Cartão de crédito <p class="paymentMethodsIcons-li-p">Parcele em até 6x sem juros</p></h5>
  	</li>
    <li class="paymentMethodsIcons-li">
      <h5 class="paymentMethodsIcons-li-h5">Boleto a prazo <p class="paymentMethodsIcons-li-p">Parcele em até 6x sem juros</p></h5>
  	</li>
  	<li class="paymentMethodsIcons-li">
      <h5 class="paymentMethodsIcons-li-h5">Boleto à vista <p class="paymentMethodsIcons-li-p">Ganhe 3% de desconto</p></h5>
  	</li>
</ul><span id="inlcude_footer_paymentMethodsIcons"></span>
        </div>
    </div>
  </div>
  <div class="footer-text">
    <div class="footer-text-content">
      Copyright © 2019 - Todos os direitos reservados | www.dentalcremer.com.br | Dental Cremer Produtos Odontológicos S.A. | CNPJ: 14.190.675/0001-55 | Rua Iguaçu, 444 - Itoupava Seca - Blumenau - Santa Catarina - CEP 89030-030 | Autorizações de Funcionamento ANVISA - Medicamentos: 1.09.245-3, Produtos para Saúde (Correlatos): 8.08.576-8, 8.10.706-3, Saneantes Domissanitários: 3.05.135-4, Perfumes/Produtos de Higiene/Cosméticos: 2.06.387-3 | CNPJ: 14.190.675/0002-36 | Av. das Indústrias Antônio Conrado de Oliveira, 90 - Galpão 03 - Distrito Industrial - Itapeva - Minas Gerais - CEP 37655-000 - Farmacêutica responsável: Paola de Souza Foltran - CRF/MG nº 38.001 | CNPJ: 14.190.675/0003-17 | Av. das Indústrias Antônio Conrado de Oliveira, 90 - Galpão 04 - Distrito Industrial - Itapeva - Minas Gerais - CEP 37655-000 - Farmacêutico responsável: Diego Diônata da Rosa - CRF/MG nº 31666. Política de Privacidade e Segurança - Fotos meramente ilustrativas - Os preços e condições da loja virtual estão sujeitos a alterações. Em caso de divergência de preços no site, o valor válido é o do Carrinho de Compras.
    </div>
  </div>
</div>

<style>
  .footer-top-content{
      width: 1120px!important;
  }
  body .footer-right{
      width: 710px!important;
  }
  body .footer-institutional{
      padding-left: 40px!important;
  }
  body .footer-institutional ul{
      min-width: 280px!important;
  }
  .footer-text-content {
      width: 1120px!important;
  }
</style> 
        </footer>
        <link rel="stylesheet" href="https://www.dentalcremer.com.br/assets/templates/1/css/styles-body.css?59">
    <script src="https://www.dentalcremer.com.br/assets/templates/1/js/body.min.js?44" type="text/javascript"></script>
    <script type="text/javascript">
    $(document).ready(function(){
      /*! Picturefill - v2.3.1 - 2015-04-09
      * http://scottjehl.github.io/picturefill
      * Copyright (c) 2015 https://github.com/scottjehl/picturefill/blob/master/Authors.txt; Licensed MIT */
      /*! matchMedia() polyfill - Test a CSS media type/query in JS. Authors & copyright (c) 2012: Scott Jehl, Paul Irish, Nicholas Zakas, David Knight. Dual MIT/BSD license */

      window.matchMedia || (window.matchMedia = function() {
        "use strict";

        // For browsers that support matchMedium api such as IE 9 and webkit
        var styleMedia = (window.styleMedia || window.media);

        // For those that don't support matchMedium
        if (!styleMedia) {
          var style       = document.createElement('style'),
            script      = document.getElementsByTagName('script')[0],
            info        = null;

          style.type  = 'text/css';
          style.id    = 'matchmediajs-test';

          script.parentNode.insertBefore(style, script);

          // 'style.currentStyle' is used by IE <= 8 and 'window.getComputedStyle' for all other browsers
          info = ('getComputedStyle' in window) && window.getComputedStyle(style, null) || style.currentStyle;

          styleMedia = {
            matchMedium: function(media) {
              var text = '@media ' + media + '{ #matchmediajs-test { width: 1px; } }';

              // 'style.styleSheet' is used by IE <= 8 and 'style.textContent' for all other browsers
              if (style.styleSheet) {
                style.styleSheet.cssText = text;
              } else {
                style.textContent = text;
              }

              // Test if media query is true or false
              return info.width === '1px';
            }
          };
        }

        return function(media) {
          return {
            matches: styleMedia.matchMedium(media || 'all'),
            media: media || 'all'
          };
        };
      }());
      /*! Picturefill - Responsive Images that work today.
      *  Author: Scott Jehl, Filament Group, 2012 ( new proposal implemented by Shawn Jansepar )
      *  License: MIT/GPLv2
      *  Spec: http://picture.responsiveimages.org/
      */
      (function( w, doc, image ) {
        // Enable strict mode
        "use strict";

        function expose(picturefill) {
          /* expose picturefill */
          if ( typeof module === "object" && typeof module.exports === "object" ) {
            // CommonJS, just export
            module.exports = picturefill;
          } else if ( typeof define === "function" && define.amd ) {
            // AMD support
            define( "picturefill", function() { return picturefill; } );
          }
          if ( typeof w === "object" ) {
            // If no AMD and we are in the browser, attach to window
            w.picturefill = picturefill;
          }
        }

        // If picture is supported, well, that's awesome. Let's get outta here...
        if ( w.HTMLPictureElement ) {
          expose(function() { });
          return;
        }

        // HTML shim|v it for old IE (IE9 will still need the HTML video tag workaround)
        doc.createElement( "picture" );

        // local object for method references and testing exposure
        var pf = w.picturefill || {};

        var regWDesc = /\s+\+?\d+(e\d+)?w/;

        // namespace
        pf.ns = "picturefill";

        // srcset support test
        (function() {
          pf.srcsetSupported = "srcset" in image;
          pf.sizesSupported = "sizes" in image;
          pf.curSrcSupported = "currentSrc" in image;
        })();

        // just a string trim workaround
        pf.trim = function( str ) {
          return str.trim ? str.trim() : str.replace( /^\s+|\s+$/g, "" );
        };

        /**
        * Gets a string and returns the absolute URL
        * @param src
        * @returns {String} absolute URL
        */
        pf.makeUrl = (function() {
          var anchor = doc.createElement( "a" );
          return function(src) {
            anchor.href = src;
            return anchor.href;
          };
        })();

        /**
        * Shortcut method for https://w3c.github.io/webappsec/specs/mixedcontent/#restricts-mixed-content ( for easy overriding in tests )
        */
        pf.restrictsMixedContent = function() {
          return w.location.protocol === "https:";
        };
        /**
        * Shortcut method for matchMedia ( for easy overriding in tests )
        */

        pf.matchesMedia = function( media ) {
          return w.matchMedia && w.matchMedia( media ).matches;
        };

        // Shortcut method for `devicePixelRatio` ( for easy overriding in tests )
        pf.getDpr = function() {
          return ( w.devicePixelRatio || 1 );
        };

        /**
        * Get width in css pixel value from a "length" value
        * http://dev.w3.org/csswg/css-values-3/#length-value
        */
        pf.getWidthFromLength = function( length ) {
          var cssValue;
          // If a length is specified and doesn’t contain a percentage, and it is greater than 0 or using `calc`, use it. Else, abort.
              if ( !(length && length.indexOf( "%" ) > -1 === false && ( parseFloat( length ) > 0 || length.indexOf( "calc(" ) > -1 )) ) {
                  return false;
              }

          /**
          * If length is specified in  `vw` units, use `%` instead since the div we’re measuring
          * is injected at the top of the document.
          *
          * TODO: maybe we should put this behind a feature test for `vw`? The risk of doing this is possible browser inconsistancies with vw vs %
          */
          length = length.replace( "vw", "%" );

          // Create a cached element for getting length value widths
          if ( !pf.lengthEl ) {
            pf.lengthEl = doc.createElement( "div" );

            // Positioning styles help prevent padding/margin/width on `html` or `body` from throwing calculations off.
            pf.lengthEl.style.cssText = "border:0;display:block;font-size:1em;left:0;margin:0;padding:0;position:absolute;visibility:hidden";

            // Add a class, so that everyone knows where this element comes from
            pf.lengthEl.className = "helper-from-picturefill-js";
          }

          pf.lengthEl.style.width = "0px";

              try {
              pf.lengthEl.style.width = length;
              } catch ( e ) {}

          doc.body.appendChild(pf.lengthEl);

          cssValue = pf.lengthEl.offsetWidth;

          if ( cssValue <= 0 ) {
            cssValue = false;
          }

          doc.body.removeChild( pf.lengthEl );

          return cssValue;
        };

          pf.detectTypeSupport = function( type, typeUri ) {
              // based on Modernizr's lossless img-webp test
              // note: asynchronous
              var image = new w.Image();
              image.onerror = function() {
                  pf.types[ type ] = false;
                  picturefill();
              };
              image.onload = function() {
                  pf.types[ type ] = image.width === 1;
                  picturefill();
              };
              image.src = typeUri;

              return "pending";
          };
        // container of supported mime types that one might need to qualify before using
        pf.types = pf.types || {};

        pf.initTypeDetects = function() {
              // Add support for standard mime types
              pf.types[ "image/jpeg" ] = true;
              pf.types[ "image/gif" ] = true;
              pf.types[ "image/png" ] = true;
              pf.types[ "image/svg+xml" ] = doc.implementation.hasFeature("http://www.w3.org/TR/SVG11/feature#Image", "1.1");
              pf.types[ "image/webp" ] = pf.detectTypeSupport("image/webp", "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAAAAAAfQ//73v/+BiOh/AAA=");
          };

        pf.verifyTypeSupport = function( source ) {
          var type = source.getAttribute( "type" );
          // if type attribute exists, return test result, otherwise return true
          if ( type === null || type === "" ) {
            return true;
          } else {
              var pfType = pf.types[ type ];
            // if the type test is a function, run it and return "pending" status. The function will rerun picturefill on pending elements once finished.
            if ( typeof pfType === "string" && pfType !== "pending") {
              pf.types[ type ] = pf.detectTypeSupport( type, pfType );
              return "pending";
            } else if ( typeof pfType === "function" ) {
              pfType();
              return "pending";
            } else {
              return pfType;
            }
          }
        };

        // Parses an individual `size` and returns the length, and optional media query
        pf.parseSize = function( sourceSizeStr ) {
          var match = /(\([^)]+\))?\s*(.+)/g.exec( sourceSizeStr );
          return {
            media: match && match[1],
            length: match && match[2]
          };
        };

        // Takes a string of sizes and returns the width in pixels as a number
        pf.findWidthFromSourceSize = function( sourceSizeListStr ) {
          // Split up source size list, ie ( max-width: 30em ) 100%, ( max-width: 50em ) 50%, 33%
          //                            or (min-width:30em) calc(30% - 15px)
          var sourceSizeList = pf.trim( sourceSizeListStr ).split( /\s*,\s*/ ),
            winningLength;

          for ( var i = 0, len = sourceSizeList.length; i < len; i++ ) {
            // Match <media-condition>? length, ie ( min-width: 50em ) 100%
            var sourceSize = sourceSizeList[ i ],
              // Split "( min-width: 50em ) 100%" into separate strings
              parsedSize = pf.parseSize( sourceSize ),
              length = parsedSize.length,
              media = parsedSize.media;

            if ( !length ) {
              continue;
            }
            // if there is no media query or it matches, choose this as our winning length
            if ( (!media || pf.matchesMedia( media )) &&
              // pass the length to a method that can properly determine length
              // in pixels based on these formats: http://dev.w3.org/csswg/css-values-3/#length-value
              (winningLength = pf.getWidthFromLength( length )) ) {
              break;
            }
          }

          //if we have no winningLength fallback to 100vw
          return winningLength || Math.max(w.innerWidth || 0, doc.documentElement.clientWidth);
        };

        pf.parseSrcset = function( srcset ) {
          /**
          * A lot of this was pulled from Boris Smus’ parser for the now-defunct WHATWG `srcset`
          * https://github.com/borismus/srcset-polyfill/blob/master/js/srcset-info.js
          *
          * 1. Let input (`srcset`) be the value passed to this algorithm.
          * 2. Let position be a pointer into input, initially pointing at the start of the string.
          * 3. Let raw candidates be an initially empty ordered list of URLs with associated
          *    unparsed descriptors. The order of entries in the list is the order in which entries
          *    are added to the list.
          */
          var candidates = [];

          while ( srcset !== "" ) {
            srcset = srcset.replace( /^\s+/g, "" );

            // 5. Collect a sequence of characters that are not space characters, and let that be url.
            var pos = srcset.search(/\s/g),
              url, descriptor = null;

            if ( pos !== -1 ) {
              url = srcset.slice( 0, pos );

              var last = url.slice(-1);

              // 6. If url ends with a U+002C COMMA character (,), remove that character from url
              // and let descriptors be the empty string. Otherwise, follow these substeps
              // 6.1. If url is empty, then jump to the step labeled descriptor parser.

              if ( last === "," || url === "" ) {
                url = url.replace( /,+$/, "" );
                descriptor = "";
              }
              srcset = srcset.slice( pos + 1 );

              // 6.2. Collect a sequence of characters that are not U+002C COMMA characters (,), and
              // let that be descriptors.
              if ( descriptor === null ) {
                var descpos = srcset.indexOf( "," );
                if ( descpos !== -1 ) {
                  descriptor = srcset.slice( 0, descpos );
                  srcset = srcset.slice( descpos + 1 );
                } else {
                  descriptor = srcset;
                  srcset = "";
                }
              }
            } else {
              url = srcset;
              srcset = "";
            }

            // 7. Add url to raw candidates, associated with descriptors.
            if ( url || descriptor ) {
              candidates.push({
                url: url,
                descriptor: descriptor
              });
            }
          }
          return candidates;
        };

        pf.parseDescriptor = function( descriptor, sizesattr ) {
          // 11. Descriptor parser: Let candidates be an initially empty source set. The order of entries in the list
          // is the order in which entries are added to the list.
          var sizes = sizesattr || "100vw",
            sizeDescriptor = descriptor && descriptor.replace( /(^\s+|\s+$)/g, "" ),
            widthInCssPixels = pf.findWidthFromSourceSize( sizes ),
            resCandidate;

            if ( sizeDescriptor ) {
              var splitDescriptor = sizeDescriptor.split(" ");

              for (var i = splitDescriptor.length - 1; i >= 0; i--) {
                var curr = splitDescriptor[ i ],
                  lastchar = curr && curr.slice( curr.length - 1 );

                if ( ( lastchar === "h" || lastchar === "w" ) && !pf.sizesSupported ) {
                  resCandidate = parseFloat( ( parseInt( curr, 10 ) / widthInCssPixels ) );
                } else if ( lastchar === "x" ) {
                  var res = curr && parseFloat( curr, 10 );
                  resCandidate = res && !isNaN( res ) ? res : 1;
                }
              }
            }
          return resCandidate || 1;
        };

        /**
        * Takes a srcset in the form of url/
        * ex. "images/pic-medium.png 1x, images/pic-medium-2x.png 2x" or
        *     "images/pic-medium.png 400w, images/pic-medium-2x.png 800w" or
        *     "images/pic-small.png"
        * Get an array of image candidates in the form of
        *      {url: "/foo/bar.png", resolution: 1}
        * where resolution is http://dev.w3.org/csswg/css-values-3/#resolution-value
        * If sizes is specified, resolution is calculated
        */
        pf.getCandidatesFromSourceSet = function( srcset, sizes ) {
          var candidates = pf.parseSrcset( srcset ),
            formattedCandidates = [];

          for ( var i = 0, len = candidates.length; i < len; i++ ) {
            var candidate = candidates[ i ];

            formattedCandidates.push({
              url: candidate.url,
              resolution: pf.parseDescriptor( candidate.descriptor, sizes )
            });
          }
          return formattedCandidates;
        };

        /**
        * if it's an img element and it has a srcset property,
        * we need to remove the attribute so we can manipulate src
        * (the property's existence infers native srcset support, and a srcset-supporting browser will prioritize srcset's value over our winning picture candidate)
        * this moves srcset's value to memory for later use and removes the attr
        */
        pf.dodgeSrcset = function( img ) {
          if ( img.srcset ) {
            img[ pf.ns ].srcset = img.srcset;
            img.srcset = "";
            img.setAttribute( "data-pfsrcset", img[ pf.ns ].srcset );
          }
        };

        // Accept a source or img element and process its srcset and sizes attrs
        pf.processSourceSet = function( el ) {
          var srcset = el.getAttribute( "srcset" ),
            sizes = el.getAttribute( "sizes" ),
            candidates = [];

          // if it's an img element, use the cached srcset property (defined or not)
          if ( el.nodeName.toUpperCase() === "IMG" && el[ pf.ns ] && el[ pf.ns ].srcset ) {
            srcset = el[ pf.ns ].srcset;
          }

          if ( srcset ) {
            candidates = pf.getCandidatesFromSourceSet( srcset, sizes );
          }
          return candidates;
        };

        pf.backfaceVisibilityFix = function( picImg ) {
          // See: https://github.com/scottjehl/picturefill/issues/332
          var style = picImg.style || {},
            WebkitBackfaceVisibility = "webkitBackfaceVisibility" in style,
            currentZoom = style.zoom;

          if (WebkitBackfaceVisibility) {
            style.zoom = ".999";

            WebkitBackfaceVisibility = picImg.offsetWidth;

            style.zoom = currentZoom;
          }
        };

        pf.setIntrinsicSize = (function() {
          var urlCache = {};
          var setSize = function( picImg, width, res ) {
                  if ( width ) {
                picImg.setAttribute( "width", parseInt(width / res, 10) );
                  }
          };
          return function( picImg, bestCandidate ) {
            var img;
            if ( !picImg[ pf.ns ] || w.pfStopIntrinsicSize ) {
              return;
            }
            if ( picImg[ pf.ns ].dims === undefined ) {
              picImg[ pf.ns].dims = picImg.getAttribute("width") || picImg.getAttribute("height");
            }
            if ( picImg[ pf.ns].dims ) { return; }

            if ( bestCandidate.url in urlCache ) {
              setSize( picImg, urlCache[bestCandidate.url], bestCandidate.resolution );
            } else {
              img = doc.createElement( "img" );
              img.onload = function() {
                urlCache[bestCandidate.url] = img.width;

                          //IE 10/11 don't calculate width for svg outside document
                          if ( !urlCache[bestCandidate.url] ) {
                              try {
                                  doc.body.appendChild( img );
                                  urlCache[bestCandidate.url] = img.width || img.offsetWidth;
                                  doc.body.removeChild( img );
                              } catch(e){}
                          }

                if ( picImg.src === bestCandidate.url ) {
                  setSize( picImg, urlCache[bestCandidate.url], bestCandidate.resolution );
                }
                picImg = null;
                img.onload = null;
                img = null;
              };
              img.src = bestCandidate.url;
            }
          };
        })();

        pf.applyBestCandidate = function( candidates, picImg ) {
          var candidate,
            length,
            bestCandidate;

          candidates.sort( pf.ascendingSort );

          length = candidates.length;
          bestCandidate = candidates[ length - 1 ];

          for ( var i = 0; i < length; i++ ) {
            candidate = candidates[ i ];
            if ( candidate.resolution >= pf.getDpr() ) {
              bestCandidate = candidate;
              break;
            }
          }

          if ( bestCandidate ) {

            bestCandidate.url = pf.makeUrl( bestCandidate.url );

            if ( picImg.src !== bestCandidate.url ) {
              if ( pf.restrictsMixedContent() && bestCandidate.url.substr(0, "http:".length).toLowerCase() === "http:" ) {
                if ( window.console !== undefined ) {
                  console.warn( "Blocked mixed content image " + bestCandidate.url );
                }
              } else {
                picImg.src = bestCandidate.url;
                // currentSrc attribute and property to match
                // http://picture.responsiveimages.org/#the-img-element
                if ( !pf.curSrcSupported ) {
                  picImg.currentSrc = picImg.src;
                }

                pf.backfaceVisibilityFix( picImg );
              }
            }

            pf.setIntrinsicSize(picImg, bestCandidate);
          }
        };

        pf.ascendingSort = function( a, b ) {
          return a.resolution - b.resolution;
        };

        /**
        * In IE9, <source> elements get removed if they aren't children of
        * video elements. Thus, we conditionally wrap source elements
        * using <!--[if IE 9]><video style="display: none;"><![endif]-->
        * and must account for that here by moving those source elements
        * back into the picture element.
        */
        pf.removeVideoShim = function( picture ) {
          var videos = picture.getElementsByTagName( "video" );
          if ( videos.length ) {
            var video = videos[ 0 ],
              vsources = video.getElementsByTagName( "source" );
            while ( vsources.length ) {
              picture.insertBefore( vsources[ 0 ], video );
            }
            // Remove the video element once we're finished removing its children
            video.parentNode.removeChild( video );
          }
        };

        /**
        * Find all `img` elements, and add them to the candidate list if they have
        * a `picture` parent, a `sizes` attribute in basic `srcset` supporting browsers,
        * a `srcset` attribute at all, and they haven’t been evaluated already.
        */
        pf.getAllElements = function() {
          var elems = [],
            imgs = doc.getElementsByTagName( "img" );

          for ( var h = 0, len = imgs.length; h < len; h++ ) {
            var currImg = imgs[ h ];

            if ( currImg.parentNode.nodeName.toUpperCase() === "PICTURE" ||
            ( currImg.getAttribute( "srcset" ) !== null ) || currImg[ pf.ns ] && currImg[ pf.ns ].srcset !== null ) {
              elems.push( currImg );
            }
          }
          return elems;
        };

        pf.getMatch = function( img, picture ) {
          var sources = picture.childNodes,
            match;

          // Go through each child, and if they have media queries, evaluate them
          for ( var j = 0, slen = sources.length; j < slen; j++ ) {
            var source = sources[ j ];

            // ignore non-element nodes
            if ( source.nodeType !== 1 ) {
              continue;
            }

            // Hitting the `img` element that started everything stops the search for `sources`.
            // If no previous `source` matches, the `img` itself is evaluated later.
            if ( source === img ) {
              return match;
            }

            // ignore non-`source` nodes
            if ( source.nodeName.toUpperCase() !== "SOURCE" ) {
              continue;
            }
            // if it's a source element that has the `src` property set, throw a warning in the console
            if ( source.getAttribute( "src" ) !== null && typeof console !== undefined ) {
              console.warn("The `src` attribute is invalid on `picture` `source` element; instead, use `srcset`.");
            }

            var media = source.getAttribute( "media" );

            // if source does not have a srcset attribute, skip
            if ( !source.getAttribute( "srcset" ) ) {
              continue;
            }

            // if there's no media specified, OR w.matchMedia is supported
            if ( ( !media || pf.matchesMedia( media ) ) ) {
              var typeSupported = pf.verifyTypeSupport( source );

              if ( typeSupported === true ) {
                match = source;
                break;
              } else if ( typeSupported === "pending" ) {
                return false;
              }
            }
          }

          return match;
        };

        function picturefill( opt ) {
          var elements,
            element,
            parent,
            firstMatch,
            candidates,
            options = opt || {};

          elements = options.elements || pf.getAllElements();

          // Loop through all elements
          for ( var i = 0, plen = elements.length; i < plen; i++ ) {
            element = elements[ i ];
            parent = element.parentNode;
            firstMatch = undefined;
            candidates = undefined;

            // immediately skip non-`img` nodes
            if ( element.nodeName.toUpperCase() !== "IMG" ) {
              continue;
            }

            // expando for caching data on the img
            if ( !element[ pf.ns ] ) {
              element[ pf.ns ] = {};
            }

            // if the element has already been evaluated, skip it unless
            // `options.reevaluate` is set to true ( this, for example,
            // is set to true when running `picturefill` on `resize` ).
            if ( !options.reevaluate && element[ pf.ns ].evaluated ) {
              continue;
            }

            // if `img` is in a `picture` element
            if ( parent && parent.nodeName.toUpperCase() === "PICTURE" ) {

              // IE9 video workaround
              pf.removeVideoShim( parent );

              // return the first match which might undefined
              // returns false if there is a pending source
              // TODO the return type here is brutal, cleanup
              firstMatch = pf.getMatch( element, parent );

              // if any sources are pending in this picture due to async type test(s)
              // remove the evaluated attr and skip for now ( the pending test will
              // rerun picturefill on this element when complete)
              if ( firstMatch === false ) {
                continue;
              }
            } else {
              firstMatch = undefined;
            }

            // Cache and remove `srcset` if present and we’re going to be doing `picture`/`srcset`/`sizes` polyfilling to it.
            if ( ( parent && parent.nodeName.toUpperCase() === "PICTURE" ) ||
            ( !pf.sizesSupported && ( element.srcset && regWDesc.test( element.srcset ) ) ) ) {
              pf.dodgeSrcset( element );
            }

            if ( firstMatch ) {
              candidates = pf.processSourceSet( firstMatch );
              pf.applyBestCandidate( candidates, element );
            } else {
              // No sources matched, so we’re down to processing the inner `img` as a source.
              candidates = pf.processSourceSet( element );

              if ( element.srcset === undefined || element[ pf.ns ].srcset ) {
                // Either `srcset` is completely unsupported, or we need to polyfill `sizes` functionality.
                pf.applyBestCandidate( candidates, element );
              } // Else, resolution-only `srcset` is supported natively.
            }

            // set evaluated to true to avoid unnecessary reparsing
            element[ pf.ns ].evaluated = true;
          }
        }

        /**
        * Sets up picture polyfill by polling the document and running
        * the polyfill every 250ms until the document is ready.
        * Also attaches picturefill on resize
        */
        function runPicturefill() {
          pf.initTypeDetects();
          picturefill();
          var intervalId = setInterval( function() {
            // When the document has finished loading, stop checking for new images
            // https://github.com/ded/domready/blob/master/ready.js#L15
            picturefill();

            if ( /^loaded|^i|^c/.test( doc.readyState ) ) {
              clearInterval( intervalId );
              return;
            }
          }, 250 );

          var resizeTimer;
          var handleResize = function() {
                picturefill({ reevaluate: true });
            };
          function checkResize() {
              clearTimeout(resizeTimer);
              resizeTimer = setTimeout( handleResize, 60 );
          }

          if ( w.addEventListener ) {
            w.addEventListener( "resize", checkResize, false );
          } else if ( w.attachEvent ) {
            w.attachEvent( "onresize", checkResize );
          }
        }

        runPicturefill();

        /* expose methods for testing */
        picturefill._ = pf;

        expose( picturefill );

      } )( window, window.document, new window.Image() );
      })
    </script>
</body>
</html>